scalar Date

type OrderCoordinates {
  icon: String
  coordinates: [Float]
}

type OrderContact {
  name: String
  phone: String
}

type OrderService {
  service: Service
  value: JSON
  remarks: String
  quotedPrice: Float
}

type OrderChargeService {
  _id: ID
  service: Service
  amount: Float
  isQuotation: Boolean
}

type OrderChargeCoupon {
  code: String!
  amount: Float!
}

type OrderChargeOther {
  _id: ID
  description: String
  amount: Float
}

type OrderCharge {
  totalAmount: Float
  hasQuote: Boolean
  currency: String
  tips: Float
  base: Float
  basePriceType: String
  services: [OrderChargeService!]
  coupons: [OrderChargeCoupon!]
  others: [OrderChargeOther!]
}

type OrderContact {
  name: String!
  phone: String!
  address: Location
}

type Order {
  _id: ID!
  orderNo: String!
  quotation: Quotation
  orderType: String!
  client: User
  clientDevice: String
  workspace: Workspace!
  date: Date
  billingContact: Address
  contactAddress: Address
  contact: OrderContact
  consignee: OrderContact
  status: Int!
  completeTime: Date
  services: [OrderService!]
  charge: OrderCharge!
  remarks: String

  # virtual populate fields
  product: OrderProduct
  time: OrderTime
  wage: OrderWage

  payment: Payment

  # only use for nearby order search
  distance: Float

  signature: FileMeta

  # generated by mongoose {timestamp: true}
  createdAt: Date
  updatedAt: Date
}

input ItemInput {
  product: ID!
  productSKU: ID!
  qty: Int!
  currency: String
  amount: Float!
}

input OrderContactInput {
  name: String
  phone: String
}

input OrderServiceInput {
  service: String
  value: JSON
  remarks: String
  quotedPrice: Float
}

input OrderChargeOtherInput {
  # chargeType: String
  description: String
  amount: Float
}

input OrderCreateModel {
  orderType: String!
  date: Date
  pickupStore: ID
  # address related fields
  contactAddressId: String
  contactAddress: AddressCreateModel
  billingContactId: String
  billingContact: AddressCreateModel
  # end of address related fields
  contact: OrderContactInput
  consignee: OrderContactInput
  services: [OrderServiceInput]
  product: OrderProductCreateModel
  time: OrderTimeCreateModel
  remarks: String
  coupon: String
  clientDevice: String
  baseCharge: Float
  tips: Float
  others: [OrderChargeOtherInput]
}

input OrderUpdateModel {
  name: String
}

type PaginateOrder {
  nodes: [Order]
  startCursor: ID
  endCursor: ID
  nodeCount: Float
  total: Float
  isEnd: Boolean
}

input OrderSearchModel {
  client: ID
  statuses: [Int!]
  pickupStores: [ID!]
  createdAtFr: String
  createdAtTo: String
  q: String
  orderNo: String
  orderType: String
  clientUserTypes: [String]
}

input OrderServiceInput {
  service: String
  value: JSON
  remarks: String
  quotedPrice: Float
}

input OrderTunnelInput {
  tunnel: String!
}

enum MerchantOrderStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

type Query {
  myOrders(
    query: OrderSearchModel
    paginate: Paginate
    options: QueryOption
  ): PaginateOrder
  myOrder(orderId: ID!): Order
  order(id: ID!): Order
  orders(
    query: OrderSearchModel
    paginate: Paginate
    options: QueryOption
  ): PaginateOrder
  orderCharge(order: OrderCreateModel): OrderCharge
}

type Mutation {
  createOrder(model: OrderCreateModel!): Order
  updateOrder(id: ID!, orderUpdateModel: OrderUpdateModel): Order
  updateOrderStatus(id: ID!, status: Int!): Order
  uploadSignature(id: ID!, files: [Upload]): Order
}
