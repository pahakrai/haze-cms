scalar Date

type ProductPriceRange {
  min: Float
  max: Float
}

type productMediaList {
  image: FileMeta
  description: String
}

type Product {
  _id: ID!
  name: String
  description: String
  # used for populate, can be omit
  category: Category
  content: String!
  images: [FileMeta]
  platformTypes: [String]
  mediaList1: [productMediaList]
  mediaList2: [productMediaList]
  mediaList3: [productMediaList]
  remarks: String
  workspace: String!
  maxAllow: Int
  tags: [Tag]
  status: Int
  types: [ProductType]
  priceRange: ProductPriceRange
  placeOfOrigin: Region
  productionDate: Date
  productExpiryDate: Date
  # virtual populate
  skus: [ProductSku]
  specs: [ProductSpec]

  # custom resolve field
  isWatched: Boolean

  # generated by mongoose {timestamp: true}
  createdAt: Date
  updatedAt: Date
}

input ProductCreateModel {
  name: String!
}

input ProductUpdateModel {
  name: String!
}

type PaginateProduct {
  nodes: [Product]
  startCursor: ID
  endCursor: ID
  nodeCount: Float
  total: Float
  isEnd: Boolean
}

input ProductSearchModel {
  q: String
  _ids: [String!]
  # category code
  tag: String
  tags: [String]
  category: String
  categories: [String]
  priceFr: Float
  priceTo: Float
  statuses: [Int]
  platformTypes: [String]
  placeOfOrigin: String
  productionDateFr: Date
  productionDateTo: Date
  productExpiryDateFr: Date
  productExpiryDateTo: Date
}

type Query {
  productsByTag(query: ProductSearchModel, paginate: Paginate): PaginateProduct
  product(id: ID!): Product
  productByPlatformType(id: ID!, platformTypes: [String]): Product
  products(
    query: ProductSearchModel
    paginate: Paginate
    options: QueryOption
  ): PaginateProduct
  productsMaybeYouLike(
    query: ProductSearchModel
    paginate: Paginate
  ): PaginateProduct
}

type Mutation {
  createProduct(productCreateModel: ProductCreateModel): Product
  updateProduct(id: ID!, productUpdateModel: ProductUpdateModel): Product
}
